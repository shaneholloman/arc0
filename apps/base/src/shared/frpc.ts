import { existsSync, mkdirSync, chmodSync, writeFileSync, unlinkSync } from "node:fs";
import { execSync } from "node:child_process";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { randomBytes } from "node:crypto";
import { BIN_DIR, FRPC_BINARY, FRPS_SERVER, FRPS_PORT } from "./config.js";

const FRP_VERSION = "0.61.1";
const FRP_GITHUB_BASE = "https://github.com/fatedier/frp/releases/download";

interface PlatformInfo {
  os: string;
  arch: string;
  ext: string;
}

/**
 * Get platform info for frpc download.
 */
function getPlatformInfo(): PlatformInfo {
  const platform = process.platform;
  const arch = process.arch;

  let os: string;
  let archStr: string;
  let ext = "tar.gz";

  // Map Node.js platform to FRP naming
  switch (platform) {
    case "darwin":
      os = "darwin";
      break;
    case "linux":
      os = "linux";
      break;
    case "win32":
      os = "windows";
      ext = "zip";
      break;
    default:
      throw new Error(`Unsupported platform: ${platform}`);
  }

  // Map Node.js arch to FRP naming
  switch (arch) {
    case "x64":
      archStr = "amd64";
      break;
    case "arm64":
      archStr = "arm64";
      break;
    case "arm":
      archStr = "arm";
      break;
    default:
      throw new Error(`Unsupported architecture: ${arch}`);
  }

  return { os, arch: archStr, ext };
}

/**
 * Get the download URL for frpc.
 */
function getDownloadUrl(): string {
  const { os, arch, ext } = getPlatformInfo();
  const filename = `frp_${FRP_VERSION}_${os}_${arch}.${ext}`;
  return `${FRP_GITHUB_BASE}/v${FRP_VERSION}/${filename}`;
}

/**
 * Check if frpc binary exists.
 */
export function frpcExists(): boolean {
  return existsSync(FRPC_BINARY);
}

/**
 * Download and extract frpc binary.
 */
export async function downloadFrpc(
  onProgress?: (message: string) => void
): Promise<void> {
  const log = onProgress || console.log;

  // Ensure bin directory exists
  if (!existsSync(BIN_DIR)) {
    mkdirSync(BIN_DIR, { recursive: true });
  }

  const { os, arch, ext } = getPlatformInfo();
  const url = getDownloadUrl();
  const archiveName = `frp_${FRP_VERSION}_${os}_${arch}`;

  log(`Downloading frpc v${FRP_VERSION} for ${os}/${arch}...`);

  // Download to temp file
  const tempFile = join(tmpdir(), `frp-${Date.now()}.${ext}`);

  try {
    // Download using curl (available on macOS/Linux)
    execSync(`curl -fsSL "${url}" -o "${tempFile}"`, { stdio: "pipe" });

    log("Extracting frpc binary...");

    if (ext === "tar.gz") {
      // Extract only the frpc binary from the archive
      execSync(
        `tar -xzf "${tempFile}" -C "${BIN_DIR}" --strip-components=1 "${archiveName}/frpc"`,
        { stdio: "pipe" }
      );
    } else if (ext === "zip") {
      // Windows - use unzip or PowerShell
      throw new Error("Windows zip extraction not yet implemented");
    }

    // Make executable
    if (existsSync(FRPC_BINARY)) {
      chmodSync(FRPC_BINARY, 0o755);
      log(`frpc installed to ${FRPC_BINARY}`);
    } else {
      throw new Error(`frpc binary not found after extraction at ${FRPC_BINARY}`);
    }
  } finally {
    // Clean up temp file
    if (existsSync(tempFile)) {
      unlinkSync(tempFile);
    }
  }
}

/**
 * Ensure frpc is available, downloading if necessary.
 */
export async function ensureFrpc(
  onProgress?: (message: string) => void
): Promise<string> {
  if (frpcExists()) {
    return FRPC_BINARY;
  }

  await downloadFrpc(onProgress);
  return FRPC_BINARY;
}

/**
 * Get frpc version info.
 */
export function getFrpcVersion(): string {
  return FRP_VERSION;
}

/**
 * Generate a random subdomain (6 characters, lowercase alphanumeric)
 */
export function generateRandomSubdomain(): string {
  return randomBytes(3).toString("hex");
}

/**
 * Generate frpc.toml configuration file.
 * Uses Go template syntax for env vars (frpc evaluates these at runtime).
 */
export function generateFrpcConfig(subdomain: string): string {
  return `# Generated by arc0 - do not edit manually
serverAddr = "${FRPS_SERVER}"
serverPort = ${FRPS_PORT}

# Bearer token passed via environment variable
metadatas.token = "{{ .Envs.ARC0_BEARER_TOKEN }}"

[[proxies]]
name = "base-socketio"
type = "http"
localIP = "127.0.0.1"
localPort = {{ .Envs.ARC0_SOCKET_PORT }}
subdomain = "${subdomain}"
`;
}
